#
# UCC initramfs tools
#
# Root filesystem mounting and partitiong for ucc
#
# Copyright 2012-2014 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

## To use this initramfs script the option boot=ucc must be given to the kernel
## command line. The following values are supported:
##  - update
##		This will update the local installed UCC image. If no partition has been
##		found, it will be partitioned
##  - local or none
##		This boots an local installed UCC image.
##  - overlayfs
##		This uses the image on the boot device as read only master image and
##		use	an overlay module.
##  - shell or debug
##		Use this to get a shell and start debugging
##		
## The following kernel commandline parameter are supported (/proc/cmdline):
##	- force_partition # TODO
##		If force_partition is given, the auto partition will not ask again.
##		This setting overwrites the value from the image.
##	- force_partition_timeout # TODO
##		Timeout in seconds for force_partitions.
##	- root=<device>
##		Specifies the root partition with the ucc image.
##	- image=<image>
##		Specifies the UCC image
##	- share=<share> # TODO
##		Specifies the share for the UCC image. This value can be set in the 
##		Managementsystem
##	- net_dev=<network device>
##		For this interface is dhclient called during the boot (default is eth0)
##	- verbose=y
##		Start set -x
##	- splash
##		is not present, plymouth will be terminated
##	- partition_script=<file>
##		custom_partition script to use for partitioning, must be placed in 
##		/var/lib/univention-client-boot/partition-scripts on all ucs ucc boot servers


# This message is send to rsyslogd and will be displayed on the console
notice ()
{
	if [ "$syslog" = "y" ]; then
		echo "$1" | logger
	fi
	echo "$1"
	if plymouth --ping; then 
		plymouth message --text="$1"
	fi
}

# This message will send to rsyslogd only
debug ()
{
	if [ "$syslog" = "y" ]; then
		echo "$1" | logger
	fi
}

failure ()
{
	. /scripts/functions

	# Load keyboard drivers
	modprobe i8042
	modprobe atkbd

	if [ -e /tmp/boot_parameter ]; then
		if grep -qs "debugshell=y" /tmp/boot_parameter; then
			debugshell=y
		fi
	elif grep -qs "debugshell=y" /proc/cmdline; then
		debugshell=y
	fi

	if [ "$debugshell" = y ]; then
		# Ensure the console is prepared for the user interaction
		run_scripts /scripts/panic
		test -n "$1" && echo "$1"
		PS1='(initramfs) ' /bin/sh -i </dev/console >/dev/console 2>&1
	else
		local msg="The boot failed. Please contact your system administrator."
		msg="$msg\nAdd debugshell=y to the boot parameters to get a debug shell."
		msg="$msg\n\nPress enter to reboot!"
		if plymouth --ping; then
			plymouth ask-question --prompt="$msg"
		else
			echo
			echo
			echo -e "$msg"
			read -n1
		fi
	fi
	reboot
}

_verbose_break ()
{
	if test "$verbose" = "y"; then
		set +x
		local msg="Pause. Press enter to continue the boot process. Insert shell to start a debug shell:"
		if plymouth --ping; then
			shell="$(plymouth ask-question --prompt="$msg")"
		else
			echo $msg
			read shell
		fi
		if [ "$shell" = "shell" ]; then
			. /scripts/functions
			# Load keyboard drivers
			modprobe i8042
			modprobe atkbd

			# Ensure the console is prepared for the user interaction
			run_scripts /scripts/panic
			echo "Dropping to a shell. Insert exit to coninue."
			/bin/sh -i </dev/console >/dev/console 2>&1
		fi
		set -x
	fi
}

## Helper function to add /dev/ to a device name
_add_dev()
{
	if echo "$1" | grep -sq ^/dev ; then
		echo "$1"
	 else
		echo "/dev/$1"
	 fi
}

## Helper function to read the environment variables
_get_var()
{
	set | sed -ne "s|'$||;s|^${1}='||p"
}


## search_devices tries to search the harddisk
search_device()
{
	local device

	for device in $(cat /proc/partitions | grep -v ^major | awk '{print $4}'); do
		if [ ! -d "/sys/block/${device}" ]; then
			# Ignore partitions
			continue
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		ro="$(cat /sys/block/${device}/ro)"
		if [ "$ro" != 0 ]; then
			# Skipping read-only device
			continue
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		cap="$(cat /sys/block/${device}/capability)"
		cap=$(echo "obase=10;ibase=16;${cap}" | bc)
		if [ "$((cap & 8))" = 8 ]; then
			# Skipping CD device
			continue
		fi

		# ignore device mapper devices
		if echo "${device}" | grep -sq ^"dm-" ; then
			# Skipping device mapper devices
			continue
		fi

		# check blacklist
		if [ -n "$device_blacklist" ]; then
			if echo "$device_blacklist" | grep -sqE "(^removable | removable | removable$|^removable$)" ; then
				# Skipping removable devices
				
				removable="$(cat /sys/block/${device}/removable)"
				if [ "$removable" = 1 ]; then
					continue
				fi
			fi
			if echo "$device_blacklist" | grep -sqE "(^${device} | ${device} | ${device}$|^${device}$)" ; then
				continue
			fi

		fi
		echo $device
		break	# Use the first device
	done

}

## Writes the fastab in the new installed system
_write_fstab()
{
	if [ ! -e "/root/etc/fstab" ] || grep -qs "^# UNCONFIGURED FSTAB FOR BASE SYSTEM" /root/etc/fstab; then
		cat >/root/etc/fstab <<__EOT__
# "# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
proc            /proc           proc    nodev,noexec,nosuid 0       0
__EOT__
	fi

	if [ -e "/ucc_tmp/fstab" ]; then
		cat /ucc_tmp/fstab >>/root/etc/fstab
	fi
	
}

## This helper copies all files from the image to a new local partition
_copy_files()
{
	local device

	if [ -e "/root/ucc_root/copy_files" ]; then
		BASE="/ucc_tmp/copy_files.d"
		mkdir -p "${BASE}"

		cat /root/ucc_root/copy_files | while read device fs mp; do
			mkdir -p "${BASE}/${mp}"
			mount -t "${fs}" "$device" "${BASE}/${mp}"
			if [ -d "/root${mp}" ]; then
				# Don't use --delete
				rsync -a "/root/${mp}" "${BASE}/${mp%/*}"
			fi
			umount "${BASE}/${mp}"
		done
	fi
	_verbose_break
}

## wrapper for the device search
_search_device()
{
	local device="$1"

	if [ "$device" = "auto" ]; then
		device="$(search_device)"
	elif [ -z "$device" ]; then
		notice "ERROR: Missing \"device: \" in ucc image configuration."
		return 1
	# else -> Using pre-defined device
	fi

	echo "$(_add_dev $device)"

	return 0
}

## Partition the harddisk
partition()
{

	local partition_device="$1"

	mkdir -p /ucc_tmp

	if [ -x /sbin/custom_partition ]; then
		# Use a custom partiton tool, this script must do the following steps:
		#	- partition the device given in $1
		#	- mount the root partition to /ucc_tmp/root
		#	- write the fstab: /ucc_tmp/fstab
		# 	- if files should be copied (normally required for /boot), it should be written to /ucc_tmp/copy_files, for example:
		#		echo "/dev/sda1 ext4 /boot" >>ucc_tmp/root/copy_files
		#	- On the root device the file /ucc_root_device must be touched
		if ! /sbin/custom_partition "$1"; then
			notice "ERROR: /sbin/custom_partition failed."
			failure
		fi
		_verbose_break
		return
	fi

	# Read and set partition table
	pt="$(/sbin/parted -s ${partition_device} unit MB print | sed -ne 's|Partition Table: ||p')"
	if [ "$pt" != "gpt" ]; then
		debug "Partition table on ${partition_device} is not gpt."
		notice "Creating GPT on ${partition_device}"
		parted -s "${partition_device}" mklabel GPT
	fi
		
	if [ -n "$remove_partitions" ]; then
		for rp in $remove_partitions; do
			if [ "$rp" = "auto" ]; then
				notice "Delete partition: auto determination"
				# TODO
				d_name="$(echo $partition_device | sed -e 's|/dev/||')"
				for partition_path in $(ls -d /sys/block/${d_name}/${d_name}* 2>/dev/null); do
					partition="$(basename $partition_path)"
					partition_number="$(echo $partition | sed -e "s|${d_name}||")"
					parted -s "${partition_device}" rm "$partition_number"
				done
			else
				rp="$(_add_dev $rp)"
				if echo "$rp" | grep -sq "^${partition_device}"; then
					notice "Delete partition: $rp"
					number=$(echo $rp | sed -ne "s|^${partition_device}||p")
					if [ -n "$number" ]; then
						debug "Delete partition: call parted -s ${partition_device} rm $number"
						parted -s "${partition_device}" rm "$number"
						
					fi
				else
					notice "Delete partition: ignore $rp"
				fi
			fi
		done
	fi

	_verbose_break
	disk_size=$(/sbin/parted -s "${partition_device}" unit MB print | sed -ne "s|^Disk ${partition_device}: ||;s|MB$||p")
	# Check 1024 partitons
	if [ -z "$partition_start" ]; then
		partition_start=1
	fi
	count=1

	i=0
	while [ $i -lt 1024 ]; do
		name="$(_get_var partition${i}_name)"
		if [ -n "$name" ];then
			# SIZE and range calculation
			size="$(_get_var partition${i}_size)"
			if [ "$size" = "expand" ]; then
				size="$((disk_size-partition_start))"
			elif echo "$size" | grep -sq "\%$"; then
				ssize="$(echo $size | sed -ne 's|%$||p')"
				size="$((disk_size*ssize/100))"
			fi
			end_mb="$((partition_start+size))"

			# Read the partition type
			type="$(_get_var partition${i}_type)"
			test -z "$type" && type="primary"

			parted -s "${partition_device}" mkpart "$type" "$partition_start" "$end_mb"

			partition_start="$end_mb"

			partition_fs="$(_get_var partition${i}_fs)"
			if [ -n "$partition_fs" ]; then
				if [ -e "/sbin/mkfs.$partition_fs" ]; then
					notice "Creating filesystem on ${partition_device}${count}"
					eval "/sbin/mkfs.$partition_fs" "${partition_device}${count}" > /dev/null 2>&1
				elif [ "$partition_fs" = "swap" ]; then
					/sbin/mkswap "${partition_device}${count}" > /dev/null 2>&1
				elif [ "$partition_fs" = "efi" ]; then
					parted -s "${partition_device}" set ${count} bios_grub on > /dev/null 2>&1
				elif [ "$partition_fs" = "esp" ]; then
					notice "Creating ESP on ${partition_device}${count}"
					/sbin/mkfs.vfat -F32 "${partition_device}${count}" > /dev/null 2>&1
					parted -s "${partition_device}" set ${count} boot on > /dev/null 2>&1
				fi
			fi
			
			partition_flags="$(_get_var partition${i}_flags)"
			if [ -n "$partition_flags" ]; then
				for flag in $partition_flags; do
					parted -s "${partition_device}" set ${count} ${flag} on
				done
			fi

			image_mount="$(_get_var partition${i}_image_mount)"
			mountpoint="$(_get_var partition${i}_mountpoint)"
			if [ "$mountpoint" = "/" ]; then
				mkdir -p /ucc_tmp/root
				mount -t $partition_fs "${partition_device}${count}" /ucc_tmp/root
				touch /ucc_tmp/root/ucc_root_device
				echo "/dev/loop0	/	$partition_fs	errors=remount-ro	0	1" >>/ucc_tmp/fstab

			elif [ "$image_mount" = "true" ]; then
				# mount these partitions later
				mkdir -p "/root/$mountpoint"
				TYPE=""
				UUID=""
				eval "$(blkid -o udev ${partition_device}${count})"
				if [ -n "$ID_FS_UUID" ]; then
					D="UUID=$ID_FS_UUID"
				else
					D="${partition_device}${count}"
				fi
				if [ "$partition_fs" = "swap" ]; then
					echo "$D	none	swap	sw	0	0" >>/ucc_tmp/fstab
				elif [ "$partition_fs" = "esp" ]; then
					echo "$D	$mountpoint	vfat	defaults	0	2" >>/ucc_tmp/fstab
				else
					echo "$D	$mountpoint	$partition_fs	defaults	0	2" >>/ucc_tmp/fstab
				fi
				
			fi
			copy_files="$(_get_var partition${i}_copy_files)"
			if [ "$copy_files" = "true" ]; then
				echo "${partition_device}${count} $partition_fs $mountpoint" >>/ucc_tmp/copy_files
			fi
			count=$((count+1))
			_verbose_break
		fi
		i=$((i+1))
	done

	test -e /ucc_tmp/copy_files && cp /ucc_tmp/copy_files /ucc_tmp/root/
}

## Search and mount the local boot device such as CDROM or USB stick. In case
## of a network boot, the network will be activated and the NFS root is mounted
_mount_local_boot_device ()
{
	notice "Mount local boot device"
	mkdir -p /ucc_tmp/boot_medium

	if [ -n "$nfsroot" ]; then
		mount -t nfs -o nolock,ro $nfsroot /ucc_tmp/boot_medium

		if [ -n "$IMAGE" -a -e "/ucc_tmp/boot_medium/${IMAGE}" ]; then
			return 0
		else
			umount /ucc_tmp/boot_medium
		fi
	fi

	for device in $(cat /proc/partitions | grep -v ^major | awk '{print $4}'); do
		ID_FS_TYPE=""
		mount_option=""
		eval "$(blkid -o udev /dev/$device)"
		if [ -n "$ID_FS_TYPE" ]; then
			mount_option="-t $ID_FS_TYPE"
		fi
		debug "Try: mount $mount_option /dev/$device /ucc_tmp/boot_medium"
		if mount $mount_option /dev/$device /ucc_tmp/boot_medium >/dev/null 2>&1; then

			notice "Found UCC device: $device"

			if [ -n "$IMAGE" -a -e "/ucc_tmp/boot_medium/${IMAGE}" ]; then
				_verbose_break
				return 0
			else
				umount /ucc_tmp/boot_medium
			fi
		fi
	done

	_verbose_break
	# Not found
	return 1
}


_sync_to_persistent ()
{
	notice "Sync files to persistent storage"
	local img="$1"
	mount -o loop "$img" /root/
	mkdir -p /root/ucc_root
	mount -o move /ucc_tmp/root /root/ucc_root
	chmod o-rwx /root/ucc_root
	if ! chroot /root /usr/sbin/univention-ucc-sync-persistent-files --sync-to-persistent >/tmp/ucclog 2>&1; then
		notice "$(cat /tmp/ucclog)"
		noitce "ERROR: Failed to sync files to persistent storage"
		failure
	else
		debug "$(cat /tmp/ucclog)"
	fi
	mount -o move /root/ucc_root /ucc_tmp/root
	umount -d /root
	
	_verbose_break
}

_sync_from_persistent ()
{
	notice "Sync files from persistent storage"
	local img="$1"
	mount -o loop "$img" /root/
	mkdir -p /root/ucc_root
	mount -o move /ucc_tmp/root /root/ucc_root
	chmod o-rwx /root/ucc_root
	if ! chroot /root /usr/sbin/univention-ucc-sync-persistent-files --sync-to-ucc >/tmp/ucclog 2>&1; then
		notice "$(cat /tmp/ucclog)"
		noitce "ERROR: Failed to sync files from persistent storage"
		failure
	else
		debug "$(cat /tmp/ucclog)"
	fi
	# run the image update script from the new image
	if [ -x /root/usr/share/univention-corporate-client/univention-ucc-image-update ]; then
		chroot /root /usr/share/univention-corporate-client/univention-ucc-image-update >/root/var/log/univention/univention-ucc-image-update.log 2>&1
	fi
	mount -o move /root/ucc_root /ucc_tmp/root
	umount -d /root

	_verbose_break
}

__get_freespace_of_mp ()
{
	df_line=$(df $1 | tail -1)
	# the busybox df tool splits the line into two lines if the source path is too long
	first_element=$(echo $df_line | awk '{print $1}')
	if echo $first_element | grep -qs '/'; then
		echo $df_line | awk '{print $4}'
	else
		echo $df_line | awk '{print $3}'
	fi
	
}
__get_size_of_file ()
{
	if [ -e "$1" ]; then
		ls -l "$1" | awk '{print $3}'
	else
		echo "0"
	fi
}

_check_free_space ()
{
	local root_space=$(__get_freespace_of_mp /ucc_tmp/root)
	# 10 MB buffer
	local buffer=10485760
	local local_image_size=0

	if [ -e /ucc_tmp/root/local_image ]; then
		local img_file="$(cat /ucc_tmp/root/local_image)"
		local local_img="/ucc_tmp/root/${img_file}"
		local_image_size="$(__get_size_of_file $local_img)"
	fi
	local remote_image_size="$(__get_size_of_file /ucc_tmp/boot_medium/$img)"

	test -z root_space && root_space=0 || root_space=$((root_space*1024))

	notice "The size of the local image and the free space: $((local_image_size+root_space))"
	notice "The size of the remote image and the buffer   : $((remote_image_size+buffer))"

	if [ $((local_image_size+root_space)) -gt $((remote_image_size+buffer)) ]; then
		return 0
	else
		return 1
	fi
}

# Helper function to wait for rsync and update plymouth message
waitForImage() {
	local pid=$1
	local msg="$2"
	while (true); do
		if kill -0 "$pid" 2>/dev/null; then
			# still running
			if [ -e "/tmp/rsync.progress" ]; then
				pg="$(cat /tmp/rsync.progress | tr -d '\r' | grep '%' | awk '{print $(NF-2) " (" $NF ")"}')"
				notice "$msg $pg"
			fi
		elif wait "$pid"; then
			# $pid exited with zero exit status
			return 0
		else
			# $pid exited with non-zero exit status
			return 1
		fi
		sleep 1
	done

	return 0
}


# Helper function to copy the image from /ucc_tmp/boot_medium/$1 to /ucc_tmp/root/
# /ucc_tmp/boot_medium/ must be mounted
_check_and_copy_image ()
{
	local img="$1"
	if [ -n "${img}" -a -e "/ucc_tmp/boot_medium/${img}" ]; then
		if ! test -e "/ucc_tmp/root/local_image.md5" || ! diff "/ucc_tmp/root/local_image.md5" "/ucc_tmp/boot_medium/${img}.md5">/dev/null ; then
			if [ -e /ucc_tmp/root/local_image ]; then
				old_image="$(cat /ucc_tmp/root/local_image)"

				if [ -e "/ucc_tmp/root/$old_image" ]; then
					_sync_to_persistent "/ucc_tmp/root/$old_image"
					touch /ucc_tmp/root/ucc_sync_back_from_persistent
				fi
			fi

			if ! _check_free_space; then
				notice "ERROR: Not enough filesystem space available"
				failure
			fi

			test -n "$old_image" -a -e "/ucc_tmp/root/$old_image" && rm "/ucc_tmp/root/$old_image"

			# A local images does not exist
			_verbose_break
			local msg="Copy UCC image to local harddisk: "
			notice "$msg"
			rsync --progress "/ucc_tmp/boot_medium/${img}" /ucc_tmp/root >/tmp/rsync.progress &
			waitForImage $! "$msg"
			if [ ! 0 -eq $? ]; then
				notice "ERROR: Failed to copy ${img}"
				return 1
			fi
			_verbose_break
			echo "${img}" >/ucc_tmp/root/local_image
			cp "/ucc_tmp/boot_medium/${img}.md5" /ucc_tmp/root/local_image.md5
			if [ -e "/ucc_tmp/root/ucc_sync_back_from_persistent" ]; then
				_sync_from_persistent "/ucc_tmp/root/${img}"
				rm "/ucc_tmp/root/ucc_sync_back_from_persistent"
			fi

			# The kernel might be upgraded during the image update
			_update_grub
			# revert boot variant to none
			touch /tmp/updated
		else
			notice "Do not copy the UCC image to local harddisk. The image was not updated."
		fi
		_verbose_break
		return 0
	else
		_verbose_break
		return 1
	fi
}

_mount_image ()
{
	image_mount=rw
	if [ "$1" = "ro" ]; then
		image_mount=ro
		modprobe overlayfs

		mkdir -p /ucc_tmp/root-ro
		mkdir -p /ucc_tmp/root-rw
	fi

	if [ -n "${IMAGE}" -a -e "/ucc_tmp/root/${IMAGE}" ]; then
		# Image was given as image= via /proc/cmdline
		local_image="${IMAGE}"
	elif [ -e "/ucc_tmp/root/local_image" ]; then
		# Use the local image if no image was given via /proc/cmdline
		local_image="$(cat /ucc_tmp/root/local_image)"
	else
        plymouth quit
        echo "Error: The UCC image assigned to this client (configurable in the UMC computer "
        echo "management module on the 'Images' tab) could not be found on the server"
        echo $nfsroot
        echo
        echo "If you are using an official UCC image you need to download the image using the"
        echo "  UCC image management module in the UMC."
        echo "If a locally customised image is to be used, it needs to be copied to"
        echo "  /var/lib/univention-client-boot."     
        failure
        return 1
	fi

	if [ "$image_mount" = "rw" ]; then
		if ! mount -o loop "/ucc_tmp/root/${local_image}" /root/; then
			_verbose_break
			return 1
		fi
		mkdir -p /root/ucc_root
		mount -o move /ucc_tmp/root /root/ucc_root
		chmod o-rwx /root/ucc_root

		# copy dhcp resolv.conf settings to the image, so we
		# we have proper dns settings for "chroot /root do something"
		if [ -e /etc/resolv.conf ] && cat /etc/resolv.conf | grep -q nameserver; then
			cp /etc/resolv.conf /root/etc/
		fi

		return 0
	else
		mount -t tmpfs tmpfs-root /ucc_tmp/root-rw

		if ! mount -o loop,ro,noload "/ucc_tmp/root/${local_image}" /ucc_tmp/root-ro; then
			notice "ERROR: failed to mount /ucc_tmp/root/${local_image}"
			failure
		fi
		if ! mount -t overlayfs -o lowerdir=/ucc_tmp/root-ro,upperdir=/ucc_tmp/root-rw overlayfs-root /root/; then
			notice "ERROR: failed to initialize overlayfs"
			failure
		fi
		mkdir -p /root/root-ro /root/root-rw /root/ucc_root
		mount -o move /ucc_tmp/root-rw /root/root-rw
		mount -o move /ucc_tmp/root-ro /root/root-ro
		mount -o move /ucc_tmp/root /root/ucc_root
		chmod o-rwx /root/ucc_root
		_verbose_break
		return 0
	fi
	_verbose_break
	return 1
}

_umount_image ()
{
	if mount | grep -qs " on /root/root-rw "; then
			mount -o move /root/ucc_root /ucc_tmp/root
			mount -o move /root/root-ro /ucc_tmp/root-ro
			mount -o move /root/root-rw /ucc_tmp/root-rw
			umount -d /root
			umount -d /ucc_tmp/root-ro
			umount -d /ucc_tmp/root-rw
	fi
	if mount | grep -qs " on /root/ucc_root "; then
		mkdir -p /ucc_tmp/root
		mount -o move /root/ucc_root /ucc_tmp/root
		umount -d /root
		return $?
	fi

}

## Copy the UCC image to the local disk
_update_local_image ()
{
	notice "Update/install local image"
	local device

	mkdir -p /ucc_tmp/boot_medium
	debug "IMAGE: $IMAGE"

	if _mount_local_boot_device; then
		if ! _check_and_copy_image "${IMAGE}"; then
			failure
		fi
		umount /ucc_tmp/boot_medium
	fi

	_mount_image
}

_parse_fstab_field ()
{
	# parse fstab file from standard input and extract a field by index
	# $1 field number
	tr '\t' ' '|tr -s ' '|grep -Ev '^\s*(#|$)'|cut -d' ' -f"$1"
}


## Install grub in the chroot. This is much easier than
## copy the whole grub stuff into the ramdisk and make grub
## compatible with busybox
_install_grub ()
{
	notice "Install grub boot loader"

	local device="$1"

	for d in dev sys proc; do
		mount -o move /${d} /root/${d}
	done

	echo "#!bin/sh" >>/root/grub-inst.sh
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot$"; then
		echo "mount /boot" >>/root/grub-inst.sh
	fi
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot/efi$"; then
		echo "mount /boot/efi >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	fi

	echo "if [ -e '/usr/share/grub/unicode.pf2' ]; then" >>/root/grub-inst.sh
	echo "cp /usr/share/grub/unicode.pf2 /boot/" >>/root/grub-inst.sh
	echo "fi" >>/root/grub-inst.sh

	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot$"; then
		echo "update-grub >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	fi
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot/efi$"; then
		echo "grub-install $device >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
		echo 'if [ "$(uname -m)" = "x86_64" ]; then' >>/root/grub-inst.sh
		echo "grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub --recheck >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
		echo 'else' >>/root/grub-inst.sh
		echo "grub-install --target=i386-efi --efi-directory=/boot/efi --bootloader-id=grub --recheck >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
		echo 'fi' >>/root/grub-inst.sh
		echo "/usr/share/univention-ucc-initramfs/scripts/set-bootable-flag-on-protective-mbr -p $device 2>&1" >>/root/grub-inst.sh
	fi

	if [ -n "$KEYBOARD" ]; then
		echo "/usr/sbin/univention-config-registry set xorg/keyboard/options/XkbLayout=$KEYBOARD >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	fi

	if [ -n "$LOCALE" ]; then
		echo "/usr/sbin/univention-config-registry set locale/default=$LOCALE >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	fi

	if [ -n "$TIMEZONE" ]; then
		echo "/usr/sbin/univention-config-registry set ucc/timezone=$TIMEZONE >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	fi
	
	if [ "$syslog" = "y" ]; then
		echo 'append="$(/usr/sbin/univention-config-registry get grub/append)" 2>&1' >>/root/grub-inst.sh
		echo 'append="$append syslog=y" 2>&1' >>/root/grub-inst.sh
		if [ -n "$syslogserver" ]; then
			echo "append=\"\$append syslogserver=$syslogserver\" 2>&1" >>/root/grub-inst.sh
		fi
		echo '/usr/sbin/univention-config-registry set grub/append="$append" 2>&1' >>/root/grub-inst.sh
	fi

	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot$"; then
		echo "umount /boot" >>/root/grub-inst.sh
	fi
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot/efi$"; then
		echo "umount /boot/efi" >>/root/grub-inst.sh
	fi

	chmod +x /root/grub-inst.sh
	chroot root ./grub-inst.sh >/tmp/ucclog 2>&1
	debug "$(cat /tmp/ucclog)"
	rm /root/grub-inst.sh

	for d in dev sys proc; do
		mount -o move /root/${d} /${d}
	done

	_verbose_break
}

_update_grub ()
{
	notice "Update grub boot loader"

	_mount_image
	for d in dev sys proc; do
		mount -o move /${d} /root/${d}
	done

	echo "#!bin/sh" >>/root/grub-update.sh
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot$"; then
		echo "mount /boot" >>/root/grub-update.sh
	fi
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot/efi$"; then
		echo "mount /boot/efi" >>/root/grub-inst.sh
	fi
	echo "update-grub >>/var/log/ucc-installation.log 2>&1" >>/root/grub-update.sh
	echo "/usr/share/univention-ucc-initramfs/scripts/set-bootable-flag-on-protective-mbr -p $device 2>&1" >>/root/grub-update.sh

	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot$"; then
		echo "umount /boot" >>/root/grub-update.sh
	fi
	if _parse_fstab_field 2 < /root/etc/fstab | grep -qs "^/boot/efi$"; then
		echo "umount /boot/efi" >>/root/grub-inst.sh
	fi

	chmod +x /root/grub-update.sh
	chroot root ./grub-update.sh >/tmp/ucclog 2>&1
	debug "$(cat /tmp/ucclog)"
	rm /root/grub-update.sh

	for d in dev sys proc; do
		mount -o move /root/${d} /${d}
	done
	_umount_image
	_verbose_break
}

waitForPartTimeout () {

	local pid=$1
	local timeout=$2
	local waited=0

	while (true); do

		# timeout indicates success
		if [ $waited -ge $timeout ]; then
			kill -9 $pid
			return 0
		fi

		if kill -0 "$pid" 2>/dev/null; then
			if plymouth --ping; then
				plymouth message --text="Starting partitioning in $((timeout-waited)) seconds. Press enter to abort."
			fi
		elif wait "$pid"; then
			return 1
		else
			return 1
		fi
		waited=$((waited+1))
		sleep 1
	done

	return 1
}

## Ask if the partiton should be done and start the post installation
## configuration
ucc_installation()
{
	local partition_device

	# clear

	test -e /scripts/ucc-config/partition_info && . /scripts/ucc-config/partition_info

	partition_device="$(_search_device ${device})"
	if [ $? != 0 ]; then
		notice "ERROR: Failed to search device."
		failure
	fi

	# Load keyboard drivers
	modprobe i8042
	modprobe atkbd

	# Ensure the console is prepared for the user interaction
	if ! plymouth --ping; then
		run_scripts /scripts/panic
	fi

	# copy part scripts
	if [ -n "$PARTITION_SCRIPT" ]; then

		mkdir /tmp/nfsroot
		if [ -e "/tmp/nfs_mount_script" ]; then
			# local boot, run script to mount boot server nfs share
			sh /tmp/nfs_mount_script
		else
			# nfs boot, mount nfsroot and copy part scripts
			mount -t nfs -o nolock,ro $nfsroot /tmp/nfsroot
		fi
		if [ -e "/tmp/nfsroot/partition-scripts/$PARTITION_SCRIPT" ]; then
			cp "/tmp/nfsroot/partition-scripts/$PARTITION_SCRIPT" /sbin/custom_partition
			chmod 755 /sbin/custom_partition
		else
			notice "Partition $PARTITION_SCRIPT script not found!"
			failure
		fi
		umount /tmp/nfsroot
	fi

	_verbose_break

	if [ "$continuation_prompt" = "false" ] || [ "$FORCE_PARTITION" = "yes" ]; then
		if [ -z "$FORCE_PARTITION_TIMEOUT" ]; then
			FORCE_PARTITION_TIMEOUT=60
		fi
		
		local timedout="false"
		if plymouth --ping; then
			plymouth watch-keystroke &
			waitForPartTimeout $! $FORCE_PARTITION_TIMEOUT
			if [ 0 -eq $? ]; then
				timedout="true"
			fi
		else
			notice "Starting partitioning in $FORCE_PARTITION_TIMEOUT seconds. Press enter to abort."
			read -t $FORCE_PARTITION_TIMEOUT tmp
			if [ ! 0 -eq $? ]; then
				timedout="true"
			fi
		fi
		if [ "$timedout" = "false" ]; then
			notice "Partitioning aborted by user!"
			failure
		fi
		partition "$partition_device"
	else
		echo -e "$continuation_message_top"
		echo -e "$continuation_message" | sed -e "s|@PARTITION_DEVICE@|$partition_device|g"

		if [ -z "$continuation_dialog" -o -z "$continuation_dialog_no" -o -z "$continuation_dialog_yes" -o -z "$continuation_dialog_error" ]; then
			notice "ERROR: continuation_dialog variables are not set."
			failure
		fi

		if plymouth --ping; then
			plymouth message --text="$continuation_message_top"
		fi

		local plymsg="$(echo "$continuation_message\n$continuation_dialog" | sed "s|@PARTITION_DEVICE@|$partition_device|g")"
		while true; do
			echo -ne "$continuation_dialog "
			if plymouth --ping; then
				# plymouth accepts only 254 characters
				plymsg="$(echo $plymsg | dd bs=1 skip=0 count=254 2>/dev/null)"
				answer="$(plymouth ask-question --prompt="$plymsg")"
			else
				read answer
			fi
			
			if [ "$answer" = "$continuation_dialog_no" ]; then
				failure "Abort partition! Dropping to a shell!"
				break
			elif [ "$answer" = "$continuation_dialog_yes" ]; then
				partition "$partition_device"
				break
			else
				plymsg="$(echo "$continuation_message\n$continuation_dialog_error" | sed "s|@PARTITION_DEVICE@|$partition_device|g")"
				echo -e "$continuation_dialog_error"
			fi
		done

	fi

	_verbose_break

	# Search image
	ucc_update
	# _update_local_image

	# Write fstab
	_write_fstab

	# Copy files from image to local partitions
	_copy_files

	# Execute a script which was created via custom_partition
	if [ -e /root/ucc_root/customer.script ]; then
		chmod +x /root/ucc_root/customer.script
		/root/ucc_root/customer.script
	fi

	# Install grub
	_install_grub "$partition_device"

}

## Start the network
_start_dhcpclient()
{
	#if [ -n "$nfsroot" ]; then
	#	# cleanup DEVICE, it will be used in the configure_networing function
	#	DEVICE=""
	#	configure_networking
	#fi

	local net_dev="$1"

	notice "Starting dhcp client"

	# alway start loopback interface
	ifconfig lo up
	ifconfig "$net_dev" up

	if [ "$?" != 0 -a "$UCC" = "overlayfs" ]; then
		while [ true ]; do
			notice "Trying to bring up $net_dev"
			ifconfig "$net_dev" up
			if [ "$?" != 0 ]; then
				sleep 1;
			else
				break;
			fi
		done
	fi

	udhcpc -s /etc/default.script -i "$net_dev" -b

	if [ -e /etc/resolv.conf ]; then
		if ! grep -q "options timeout:" /etc/resolv.conf; then 
			echo "options timeout:2" >> /etc/resolv.conf
		fi
	fi
}

# start the static network
_start_static_network()
{
	# Image is mounted as /ucc_tmp/root
	chroot /root /usr/sbin/ucr --shell search interfaces gateway nameserver>/tmp/ucr_interfaces
	cat /tmp/ucr_interfaces | while read line; do
		if [ -n "$(echo $line | grep _address=)" ]; then
			iface="$(echo $line | sed -e 's|interfaces_\(.*\)_address=.*|\1|')"
			addr=$(cat /tmp/ucr_interfaces | sed -ne "s|interfaces_${iface}_address=||p")
			mask=$(cat /tmp/ucr_interfaces | sed -ne "s|interfaces_${iface}_netmask=||p")
			ifconfig "${iface}" "${addr}" netmask "${mask}" up
		fi
	done
	rm /tmp/ucr_interfaces
}

start_upgrade_script()
{
	if [ ! -e /tmp/upgrade_script ]; then
		chroot /root /usr/share/univention-ucc-initramfs/scripts/generate_upgrade_script >/tmp/upgrade_script
	fi

	if [ -e /tmp/upgrade_script ]; then
		chmod +x /tmp/upgrade_script
		_umount_image
		if test "$verbose" = "y"; then
			sh -x /tmp/upgrade_script 2>&1 | tee /tmp/ucclog
		else
			/tmp/upgrade_script 2>&1 | tee /tmp/ucclog
		fi
		debug "$(cat /tmp/ucclog)"
		_mount_image
	fi
	_verbose_break
}

## Update the local UCC image
ucc_update()
{
	mkdir -p /ucc_tmp/root

	# If the root device was set to search or /dev/nfs and the system
	# should be updated, this system must be installed
	if [ "${ROOT}" = "search" -o "${ROOT}" = "/dev/nfs" ]; then
		if ! _mount_local_root_device; then
			notice "A local root device has not been found. Switch to the installation mode!"
			ucc_installation
			return
		fi

		_update_local_image

	else
		# In this case we boot from local boot menu
		# 		mount the local root device
		#		bring up the local network with the configuration from the root device
		#		chroot into the local boot device
		#		search for images updates
		if ! LC_ALL=C mount | grep -qs " on /ucc_tmp/root"; then
			mount ${ROOT} /ucc_tmp/root
		fi

		if [ -e /tmp/upgrade_script ]; then
			start_upgrade_script
		else
			if ! _mount_image; then
				notice "ERROR: failed to mount the local image"
				failure
			fi
			if [ -e /root/var/univention-join/joined ]; then
				# The system is joined. An image upgrade 
				# is possible. So dive into the image and boot
				if _start_static_network; then
					start_upgrade_script
				fi
			fi
		fi
	fi

	_verbose_break
	return 0
}

_mount_local_root_device()
{
	local device
	notice "Mount local root device"

	umount -d /ucc_tmp/root >/dev/null 2>&1

	cat /proc/partitions | grep -v ^major | awk '{print $1" "$2" "$4}' | while read major minor device; do
		ID_FS_TYPE=""
		mount_option=""

		test -z "$device" && continue

		eval "$(blkid -o udev /dev/$device)"
		if [ -n "$ID_FS_TYPE" ]; then
			mount_option="-t $ID_FS_TYPE"
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		if [ "$minor" = 0 ]; then
			sys_path="/sys/block/${device}"
		else
			# get major device for sys ro path
			major_device="$(awk '{if ($1=='$major' && $2==0) { print $4}}' /proc/partitions)"
			sys_path="/sys/block/${major_device}/${device}"
		fi
		if [ -e "${sys_path}/ro" ]; then
			ro="$(cat ${sys_path}/ro)"
			if [ "$ro" != 0 ]; then
				# Skipping read-only device
				continue
			fi
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		if [ -e "${sys_path}/capability)" ]; then
			cap="$(cat ${sys_path}/capability)"
			cap=$(echo "obase=10;ibase=16;${cap}" | bc)
			if [ "$((cap & 8))" = 8 ]; then
				# Skipping CD device
				continue
			fi
		fi
		if mount $mount_option /dev/$device /ucc_tmp/root >/dev/null 2>&1; then

			if [ -e "/ucc_tmp/root/ucc_root_device" ]; then
				# This is the root device
				notice "Found a local ucc root device: /dev/$device"
				break
			else
				umount -d /ucc_tmp/root >/dev/null 2>&1
			fi

		fi
	done

	test -e "/ucc_tmp/root/ucc_root_device"
	return $?
}

## Boot into the local UCC image
ucc_image_local()
{
	mkdir -p /ucc_tmp/root

	if [ "${ROOT}" = "search" -o "${ROOT}" = "/dev/nfs" ]; then
		if ! _mount_local_root_device; then
			notice "ERROR: local root device was not found. Try kernel commandline argument root=</dev/...>"
			failure
		fi
	else
		mount ${ROOT} /ucc_tmp/root
	fi

	_mount_image

	if ! mount | grep -qs " on /root "; then
		notice "ERROR: An UCC image was not found!"
		failure
	fi
}

ucc_image_ro()
{
	local device

	if _mount_local_boot_device; then

		modprobe "overlayfs"

		mkdir -p /ucc_tmp/root-ro
		mkdir -p /ucc_tmp/root-rw
		
		mount -t tmpfs tmpfs-root /ucc_tmp/root-rw

		if [ -n "${IMAGE}" -a -e "/ucc_tmp/boot_medium/${IMAGE}" ]; then
			mount -o loop,ro,noload /ucc_tmp/boot_medium/${IMAGE} /ucc_tmp/root-ro
			break
		fi

		if ! mount | grep -qs " on /ucc_tmp/root-ro "; then
			notice "ERROR: An UCC image was not found!"
			failure
		fi
			
		mount -t overlayfs -o lowerdir=/ucc_tmp/root-ro,upperdir=/ucc_tmp/root-rw overlayfs-root /root/

		mkdir -p /root/root-rw /root/root-ro /root/root-boot_medium
		mount -o move /ucc_tmp/root-rw /root/root-rw
		mount -o move /ucc_tmp/root-ro /root/root-ro
		mount -o move /ucc_tmp/boot_medium /root/root-boot_medium
	else
		notice "ERROR: A local boot device was not found."
		failure
	fi
	
}

waitForJoin() {

	local pid=$1
	local infoFile="$2"
	local msg=""

	while (true); do
		if kill -0 "$pid" 2>/dev/null; then
			# still running
			if [ -e "$infoFile" ] && plymouth --ping; then
				msg="$(cat $infoFile | tail -1 | tr -d '\033' | sed 's/\[60G/ ... /g')"
				if [ -n "$msg" ]; then
					notice "$msg"
				fi
			fi
		elif wait "$pid"; then
			# $pid exited with zero exit status
			return 0
		else
			# $pid exited with non-zero exit status
			return 1
		fi
		sleep 1
	done

	return 0
}

# Rollout
ucc_rollout ()
{
	# Load keyboard drivers
	modprobe i8042
	modprobe atkbd

	local autojoin="false"
	local join_user=""
	local join_password=""
	local join_domain=""
	local testdom="$(cat /etc/resolv.conf | grep ^domain | tail -1 | awk '{print $2}')"
	local joinRetval=0
	local failedMsg=""

	if [ ! -e /root/var/univention-join/joined ]; then

		if ! plymouth --ping; then
			# Ensure the console is prepared for the user interaction
			run_scripts /scripts/panic
		fi

		notice "Joining the UCC client"

		# autojoin
		if [ -e /root/etc/ucc_join_user -a -e /root/etc/ucc_join_password -a -e /root/etc/ucc_join_domain ]; then
			autojoin="true"
			join_user="$(cat /root/etc/ucc_join_user)"
			join_password="/etc/ucc_join_password"
			join_domain="$(cat /root/etc/ucc_join_domain)"
		fi

		# plymouth
		if [ "$autojoin" = "false" ] && plymouth --ping; then
			join_domain="$(plymouth ask-question --prompt="Insert domain name of client [$testdom]:")"
			if [ -z "$join_domain" ]; then
				join_domain="$testdom"
			fi
			join_user="$(plymouth ask-question --prompt="Insert DC Master Account [Administrator]:")"
			if [ -z "$join_user" ]; then
			        join_user="Administrator"
			fi
			while (true); do
			        join_password="$(plymouth ask-for-password --prompt="Insert DC Master Password:")"
			        if [ -n "$join_password" ]; then
			                break
			        fi
			done
			echo "$join_password" > "/root/tmp/.pass"
			join_password="/tmp/.pass"
	
		fi

		mount -o move /proc /root/proc
		# Copy resolv.conf into chroot. If the resolv.conf does
		# not exist, start the network and ignore the output, since
		# upstart is not running
		if [ -e /etc/resolv.conf ]; then
			cp /etc/resolv.conf /root/etc/
		else
			chroot /root /etc/init.d/networking restart >/dev/null 2>&1
		fi

		# join the system, noninteractive
		if [ -n "$join_user" -a -n "$join_password" -a -n "$join_domain" ]; then
			chroot /root /usr/sbin/univention-join \
				-dcaccount "$join_user" \
				-dcpwd "$join_password" \
				-domainname "$join_domain" 2>&1 >/tmp/ucclog &
			waitForJoin $! "/tmp/ucclog"
			joinRetval=$?
		# join the system, interactive
		else
			# Ensure the console is prepared for the user interaction
			run_scripts /scripts/panic
			chroot /root /usr/sbin/univention-join 2>&1
			joinRetval=$?
		fi

		# remove join data
		if [ -e "/root/$join_password" ]; then
			rm "/root/$join_password"
		fi
		if [ -e "/root/etc/ucc_join_user" ]; then
			rm "/root/etc/ucc_join_user"
		fi
		if [ -e "/root/etc/ucc_join_domain" ]; then
			rm "/root/etc/ucc_join_domain"
		fi

		debug "$(cat /tmp/ucclog)"
		mount -o move /root/proc /proc

		if [ 0 -eq $joinRetval ]; then
			notice "Joined successfully"
		else
			if [ -e /tmp/ucclog ]; then
				failedMsg="$(cat /tmp/ucclog | grep '* Message: '| tail -1 | awk -F 'Message: ' '{print $2}')"
			fi

			if [ -n "$failedMsg" ]; then
				failedMsg="ERROR: Failed to join. ($failedMsg)"
			else
				failedMsg="ERROR: Failed to join."
			fi
			notice "$failedMsg"
			failure
		fi
	fi
}

set_boot_variant ()
{
	# Reset the boot flag for this client
	if ! chroot /root /usr/share/univention-ucc-initramfs/scripts/set_boot_variant.sh none >/tmp/ucclog 2>&1; then
		debug "$(cat /tmp/ucclog)"
	fi
}


get_boot_mount_option ()
{
	# Read  the boot mount option ro or rw from mounted image
	chroot /root /usr/share/univention-ucc-initramfs/scripts/get_boot_mount_option.sh
	return 0	
}

remote_logging ()
{
	# Send everything to the syslog server
	if [ "$syslog" = "y" ]; then
		if [ -z "$syslogserver" ]; then
			notice "WARNING: syslogserver is not set. Do not start logger."
			echo "*.*	/dev/tty2" >>/etc/rsyslog.conf
		else
			#Disable the global redirect since it does not work in the default shell
			#exec 3>&1 > >(tee -a /dev/fd/3 | logger -n "$syslogserver") 2>&1
			echo "*.*	@$syslogserver:514" >>/etc/rsyslog.conf
		fi
		mkdir -p /var/run/ /var/spool/rsyslog
		rsyslogd -c 4 >>/dev/tty2 2>&1
	fi
}

stop_remote_logging ()
{
	debug "Stop rsyslogd"
	test -e /var/run/rsyslogd.pid && kill "$(cat /var/run/rsyslogd.pid)"
}

check_parameter ()
{
	for x in $(cat $1); do
		case $x in
		ucc=*)
			UCC=${x#ucc=}
			;;
		image=*)
			IMAGE=${x#image=}
			;;
		share=*)
			SHARE=${x#share=}
			;;
		repartition=*)
			REPARTITION=${x#repartition=}
			;;
		force_partition)
			FORCE_PARTITION=yes
			;;
		force_partition_timeout=*)
			FORCE_PARTITION_TIMEOUT=${x#force_partition_timeout=}
			;;
		net_dev=*)
			net_dev=${x#net_dev=}
			;;
		keyboard*)
			KEYBOARD=${x#keyboard=}
			;;
		locale*)
			LOCALE=${x#locale=}
			;;
		timezone*)
			TIMEZONE=${x#timezone=}
			;;
		verbose=*)
			verbose=${x#verbose=}
			;;
		syslog=*)
			syslog=${x#syslog=}
			;;
		syslogserver=*)
			syslogserver=${x#syslogserver=}
			;;
		debugshell=*)
			debugshell=${x#debugshell=}
			;;
		splash*)
			SPLASH="true"
			;;
		partition_script=*)
			PARTITION_SCRIPT=${x#partition_script=}
			;;
		esac
	done
}

mountroot()
{
	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
	run_scripts /scripts/local-top
	[ "$quiet" != "y" ] && log_end_msg

	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
	run_scripts /scripts/local-premount
	[ "$quiet" != "y" ] && log_end_msg

	clear

	udevadm settle # wait for udev

	check_parameter /proc/cmdline

	# stop plymouthd if splash is not set
	if [ -n "$SPLASH" -a "$SPLASH" = "true" ]; then
		:
	else
		plymouth quit
	fi	

	test "$verbose" = "y" && set -x

	# Set defaults
	test -z "$ROOT" && ROOT="search"
	test -z "$net_dev" && net_dev="eth0"

	export IMAGE SHARE FORCE_PARTITION FORCE_PARTITION_TIMEOUT

	_start_dhcpclient "$net_dev"

	remote_logging

	# Check if the LDAP settings override the local boot settings
	if [ "${ROOT}" != "search" -a "${ROOT}" != "/dev/nfs" ]; then
		mkdir -p /ucc_tmp/root
		mount ${ROOT} /ucc_tmp/root
		if _mount_image; then
			if [ -e /root/var/univention-join/joined ]; then
				if chroot /root /usr/sbin/univention-ucc-boot-option --read >/tmp/boot_parameter; then
					notice "Read and set LDAP boot parameter"
					debug "LDAP boot parameter: $(cat /tmp/boot_parameter)"
					check_parameter /tmp/boot_parameter
				fi
				chroot /root /usr/share/univention-ucc-initramfs/scripts/generate_upgrade_script >/tmp/upgrade_script
				chroot /root /usr/share/univention-ucc-initramfs/scripts/generate_nfs_mount_script >/tmp/nfs_mount_script
			fi
			
			_umount_image
		fi
		umount /ucc_tmp/root

		test "$verbose" = "y" && set -x || set +x

		# Restart remote logging, the values may have been changed
		# TODO: check if the restart is really necessary
		stop_remote_logging
		remote_logging
	fi

	_verbose_break

	# INSTALLATION
	if [ "$REPARTITION" = "y" ]; then
		notice "Starting repartition"
		sleep 1 # Give udevadm one more second
		ucc_installation
		# Start rollout
		ucc_rollout
	# IMAGE UPDATE
	elif [ "$UCC" = "rollout" ]; then
		notice "Starting UCC rollout mode"
		ucc_update
		# Copy files from image to local partitions
		_copy_files
		ucc_rollout
		if [ -e /tmp/updated ]; then
			set_boot_variant
		fi
	# LIVE SYSTEM
	elif [ "$UCC" = "overlayfs" ]; then
		notice "Starting UCC overlayfs mode"
		ucc_image_ro
	elif [ "$UCC" = "shell" -o "$UCC" = "debug" ]; then
		notice "Starting UCC shell"
		failure
	else # $UCC = local
		notice "Starting UCC local mode"
		ucc_image_local
	fi

	# mount the image ro if requested
	mount_option="$(get_boot_mount_option)"
	if [ -n "$mount_option" ]; then
		if mount | grep -q "on /root-ro"; then
			if [ "$mount_option" = "rw" ]; then
				_umount_image
				_mount_image rw
			fi
		elif [ "$mount_option" = "ro" ]; then
			_umount_image
			_mount_image ro
		fi
	fi

	_verbose_break

	stop_remote_logging

	# until here the dhcp|previous resolv.conf is used, from
	# now on the UCR resolv.conf (if the system is joined)
	if [ -e /root/var/univention-join/joined ]; then
		chroot /root /usr/sbin/ucr commit /etc/resolv.conf
	fi
}
