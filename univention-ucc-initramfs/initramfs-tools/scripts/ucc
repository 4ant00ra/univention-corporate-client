#
# UCC initramfs tools
#
# Root filesystem mounting and partitiong for ucc
#
# Copyright 2012 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

## To use this initramfs script the option boot=ucc must be given to the kernel
## command line. The followin values are supported:
##  - inst
##		Perform an installation to the local harddisk. WARNING: local
##		partitions will be deleted!
##  - update
##		This will update the local installed UCC image. If no partition has been
##		found, it will be partitioned
##  - local or none
##		This boots an local installed UCC image.
##  - overlayfs
##		This uses the image on the boot device as read only master image and
##		use	an overlay module.
##  - aufs
##		This uses the image on the boot device as read only master image and
##		use	an aufs module.
##  - shell or debug
##		Use this to get a shell and start debugging
##		
## The following kernel commandline parameter are supported (/proc/cmdline):
##	- force_partition # TODO
##		If force_partition is given, the auto partition will not ask again.
##		This setting overwrites the value from the image.
##	- force_partition_timeout # TODO
##		Timeout in seconds for force_partitions.
##	- root=<device>
##		Specifies the root partition with the ucc image.
##	- image=<image>
##		Specifies the UCC image
##	- share=<share> # TODO
##		Specifies the share for the UCC image. This value can be set in the 
##		Managementsystem
##	- net_dev=<network device>
##		For this interface is dhclient called during the boot (default is eth0)

## Helper function to add /dev/ to a device name
_add_dev()
{
	if echo "$1" | grep -sq ^/dev ; then
		echo "$1"
	 else
		echo "/dev/$1"
	 fi
}

## Helper function to read the environment variables
_get_var()
{
	set | sed -ne "s|'$||;s|^${1}='||p"
}


## search_devices tries to search the harddsik
search_device()
{
	local device

	for device in $(cat /proc/partitions | grep -v ^major | awk '{print $4}'); do
		if [ ! -d "/sys/block/${device}" ]; then
			# Ignore partitions
			continue
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		ro="$(cat /sys/block/${device}/ro)"
		if [ "$ro" != 0 ]; then
			# Skipping read-only device
			continue
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		cap="$(cat /sys/block/${device}/capability)"
		cap=$(echo "obase=10;ibase=16;${cap}" | bc)
		if [ "$((cap & 8))" = 8 ]; then
			# Skipping CD device
			continue
		fi

		# ignore device mapper devices
		if echo "${device}" | grep -sq ^"dm-" ; then
			# Skipping device mapper devices
			continue
		fi

		# check blacklist
		if [ -n "$device_blacklist" ]; then
			if echo "$device_blacklist" | grep -sqE "(^removable | removable | removable$|^removable$)" ; then
				# Skipping removable devices
				
				removable="$(cat /sys/block/${device}/removable)"
				if [ "$removable" = 1 ]; then
					continue
				fi
			fi
			if echo "$device_blacklist" | grep -sqE "(^${device} | ${device} | ${device}$|^${device}$)" ; then
				continue
			fi

		fi
		echo $device
		break	# Use the first device
	done
}

## Writes the fastab in the new installed system
_write_fstab()
{
	if [ ! -e "/root/etc/fstab" ] || grep -qs "^# UNCONFIGURED FSTAB FOR BASE SYSTEM" /root/etc/fstab; then
		cat >/root/etc/fstab <<__EOT__
# "# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
proc            /proc           proc    nodev,noexec,nosuid 0       0
__EOT__
	fi

	if [ -e "/ucc_tmp/fstab" ]; then
		cat /ucc_tmp/fstab >>/root/etc/fstab
	fi
	
}

## This helper copies all files from the image to a new local partition
_copy_files()
{
	local device

	if [ -e "/ucc_tmp/copy_files" ]; then
		BASE="/ucc_tmp/copy_files.d"
		mkdir -p "${BASE}"

		cat /ucc_tmp/copy_files | while read device fs mp; do
			mkdir -p "${BASE}/${mp}"
			mount -t "${fs}" "$device" "${BASE}/${mp}"
			if [ -d "/root${mp}" ]; then
				cp -a "/root/${mp}" "${BASE}/${mp%/*}/"
			fi
			umount "${BASE}/${mp}"
		done
	fi
}

## wrapper for the device search
_search_device()
{
	local device="$1"

	if [ "$device" = "auto" ]; then
		device="$(search_device)"
	elif [ -z "$device" ]; then
		echo "ERROR: Missing \"device: \" in ucc image configuration."
		return 1
	# else -> Using pre-defined device
	fi

	echo "$(_add_dev $device)"

	return 0
}

## Partition the harddsik
partition()
{

	local partition_device="$1"

	mkdir -p /ucc_tmp

	# Read and set partition table
	pt="$(/sbin/parted -s ${partition_device} unit MB print | sed -ne 's|Partition Table: ||p')"
	if [ "$pt" != "gpt" ]; then
		echo "Partition table on ${partition_device} is not gpt."
		echo "Creating GPT on ${partition_device}"
		parted -s "${partition_device}" mklabel GPT
	fi
		
	if [ -n "$remove_partitions" ]; then
		for rp in $remove_partitions; do
			if [ "$rp" = "auto" ]; then
				echo "INFO: delete partition: auto determination"
				# TODO
				d_name="$(echo $partition_device | sed -e 's|/dev/||')"
				for partition_path in $(ls -d /sys/block/${d_name}/${d_name}* 2>/dev/null); do
					partition="$(basename $partition_path)"
					partition_number="$(echo $partition | sed -e "s|${d_name}||")"
					parted -s "${partition_device}" rm "$partition_number"
				done
			else
				rp="$(_add_dev $rp)"
				if echo "$rp" | grep -sq "^${partition_device}"; then
					echo "INFO: delete partition: $rp"
					number=$(echo $rp | sed -ne "s|^${partition_device}||p")
					if [ -n "$number" ]; then
						echo "INFO: delete partition: call parted -s ${partition_device} rm $number"
						parted -s "${partition_device}" rm "$number"
						
					fi
				else
					echo "INFO: delete partition: ignore $rp"
				fi
			fi
		done
	fi

	disk_size=$(/sbin/parted -s "${partition_device}" unit MB print | sed -ne "s|^Disk ${partition_device}: ||;s|MB$||p")
	# Check 1024 partitons
	if [ -z "$partition_start" ]; then
		partition_start=1
	fi
	count=1

	i=0
	while [ $i -lt 1024 ]; do
		name="$(_get_var partition${i}_name)"
		if [ -n "$name" ];then
			# SIZE and range calculation
			size="$(_get_var partition${i}_size)"
			if [ "$size" = "expand" ]; then
				size="$((disk_size-partition_start))"
			elif echo "$size" | grep -sq "\%$"; then
				ssize="$(echo $size | sed -ne 's|%$||p')"
				size="$((disk_size*ssize/100))"
			fi
			end_mb="$((partition_start+size))"

			parted -s "${partition_device}" mkpart "$name" "$partition_start" "$end_mb"

			partition_start="$end_mb"

			partition_fs="$(_get_var partition${i}_fs)"
			if [ -n "$partition_fs" ]; then
				if [ -e "/sbin/mkfs.$partition_fs" ]; then
					echo "Creating filesystem on ${partition_device}${count}"
					eval "/sbin/mkfs.$partition_fs" "${partition_device}${count}" > /dev/null 2>&1
				elif [ "$partition_fs" = "swap" ]; then
					/sbin/mkswap "${partition_device}${count}" > /dev/null 2>&1
				elif [ "$partition_fs" = "efi" ]; then
					parted -s "${partition_device}" set ${count} bios_grub on > /dev/null 2>&1
				fi
			fi
			
			partition_flags="$(_get_var partition${i}_flags)"
			if [ -n "$partition_flags" ]; then
				for flag in $partition_flags; do
					parted -s "${partition_device}" set ${count} ${flag} on
				done
			fi

			image_mount="$(_get_var partition${i}_image_mount)"
			mountpoint="$(_get_var partition${i}_mountpoint)"
			if [ "$mountpoint" = "/" ]; then
				mkdir -p /ucc_tmp/root
				mount -t $partition_fs "${partition_device}${count}" /ucc_tmp/root
				touch /ucc_tmp/root/ucc_root_device
				echo "/dev/loop0	/	$partition_fs	errors=remount-ro	0	1" >>/ucc_tmp/fstab

			elif [ "$image_mount" = "true" ]; then
				# mount these partitions later
				mkdir -p "/root/$mountpoint"
				TYPE=""
				UUID=""
				eval "$(blkid -o udev ${partition_device}${count})"
				if [ -n "$ID_FS_UUID" ]; then
					D="UUID=$ID_FS_UUID"
				else
					D="${partition_device}${count}"
				fi
				if [ "$partition_fs" = "swap" ]; then
					echo "$D	none	swap	sw	0	0" >>/ucc_tmp/fstab
				else
					echo "$D	$mountpoint	$partition_fs	defaults	0	2" >>/ucc_tmp/fstab
				fi
				
			fi
			copy_files="$(_get_var partition${i}_copy_files)"
			if [ "$copy_files" = "true" ]; then
				echo "${partition_device}${count} $partition_fs $mountpoint" >>ucc_tmp/copy_files
			fi
			count=$((count+1))
		fi
		i=$((i+1))
	done

}

## Search and mount the local boot device such as CDROM or USB stick. In case
## of a network boot, the network will be activated and the NFS root is mounted
_mount_local_boot_device ()
{
	echo "INFO: Mount local boot device"
	mkdir -p /ucc_tmp/boot_medium

	if [ -n "$nfsroot" ]; then
		# cleanup DEVICE, it will be used in the configure_networing function
		DEVICE=""
		configure_networking

		mount -t nfs -o nolock,ro $nfsroot /ucc_tmp/boot_medium

		if [ -n "$IMAGE" -a -e "/ucc_tmp/boot_medium/${IMAGE}" ]; then
			return 0
		else
			umount /ucc_tmp/boot_medium
		fi
	fi

	for device in $(cat /proc/partitions | grep -v ^major | awk '{print $4}'); do
		ID_FS_TYPE=""
		mount_option=""
		eval "$(blkid -o udev /dev/$device)"
		if [ -n "$ID_FS_TYPE" ]; then
			mount_option="-t $ID_FS_TYPE"
		fi
		if mount $mount_option /dev/$device /ucc_tmp/boot_medium; then

			echo "Found UCC device: $device"

			if [ -n "$IMAGE" -a -e "/ucc_tmp/boot_medium/${IMAGE}" ]; then
				return 0
			else
				umount /ucc_tmp/boot_medium
			fi
		fi
	done

	# Not found
	return 1
}


_sync_to_persistent ()
{
	echo "INFO: Sync files to persistent storage"
	local img="$1"
	mount -o loop "$img" /root/
	mkdir -p /root/ucc_root
	mount -o move /ucc_tmp/root /root/ucc_root
	chroot /root /usr/sbin/univention-ucc-sync-persistent-files --sync-to-persistent
	mount -o move /root/ucc_root /ucc_tmp/root
	umount /root
	
}

_sync_from_persistent ()
{
	echo "INFO: Sync files from persistent storage"
	local img="$1"
	mount -o loop "$img" /root/
	mount -o move /ucc_tmp/root /root/ucc_root
	chroot /root /usr/sbin/univention-ucc-sync-persistent-files --sync-to-ucc
	mount -o move /root/ucc_root /ucc_tmp/root
	umount /root
}

# Helper function to copy the image from /ucc_tmp/boot_medium/$1 to /ucc_tmp/root/
# /ucc_tmp/boot_medium/ must be mounted
_check_and_copy_image ()
{
	local img="$1"
	if [ -n "${img}" -a -e "/ucc_tmp/boot_medium/${img}" ]; then
		if ! test -e "/ucc_tmp/root/local_image.md5" || ! diff "/ucc_tmp/root/local_image.md5" "/ucc_tmp/boot_medium/${img}.md5">/dev/null ; then
			if [ -e /ucc_tmp/root/local_image ]; then
				old_image="$(cat /ucc_tmp/root/local_image)"

				if [ -e "/ucc_tmp/root/$old_image" ]; then
					_sync_to_persistent "/ucc_tmp/root/$old_image"
					touch /ucc_tmp/root/ucc_sync_back_from_persistent
				fi
			fi

			# Move the image to the new name
			if [ -n "$old_image" -a -e "/ucc_tmp/root/$old_image" ]; then
				mv "/ucc_tmp/root/$old_image" "/ucc_tmp/root/${img}"
			fi

			# A local images does not exist
			echo "INFO: Copy UCC image to local harddsik: "
			# TODO: check return value
			rsync --progress "/ucc_tmp/boot_medium/${img}" /ucc_tmp/root
			echo "${img}" >/ucc_tmp/root/local_image
			cp "/ucc_tmp/boot_medium/${img}.md5" /ucc_tmp/root/local_image.md5
			if [ -e "/ucc_tmp/root/ucc_sync_back_from_persistent" ]; then
				_sync_from_persistent "/ucc_tmp/root/${img}"
				rm "/ucc_tmp/root/ucc_sync_back_from_persistent"
			fi
		else
			echo "INFO: Do not copy the UCC image to local harddsik. The image was not updated."
		fi
		sleep 60
		return 0
	else
		return 1
	fi
}

_mount_image ()
{
	if [ -e "/ucc_tmp/root/local_image" ]; then
		local_image="$(cat /ucc_tmp/root/local_image)"
		if mount -o loop "/ucc_tmp/root/${local_image}" /root/; then
			return 0
		fi
	fi
	return 1
}

_umount_image ()
{
	umount /root
	return $?
}

_final_root_mount ()
{
	if [ -e "/ucc_tmp/root/local_image" ]; then
		if ! _mount_image; then
				echo "ERROR: failed to mount /ucc_tmp/root/${local_image} to /root"
				panic "Dropping to a shell!"
		fi

		mkdir -p /root/ucc_root
		mount -o move /ucc_tmp/root /root/ucc_root

		return 0
	fi
	return 1
}

## Copy the UCC image to the local disk
_update_local_image ()
{
	echo "INFO: Update/install local image"
	local device

	mkdir -p /ucc_tmp/boot_medium
	echo "IMAGE: $IMAGE"

	if _mount_local_boot_device; then
		_check_and_copy_image "${IMAGE}"
		umount /ucc_tmp/boot_medium
	fi

	_final_root_mount
}

## Install grub in the chroot. This is much easier than
## copy the whole grub stuff into the ramdisk and make grub
## compatible with busybox
_install_grub ()
{
	echo "INFO: Install grub boot loader"

	local device="$1"

	for d in dev sys proc; do
		mount -o move /${d} /root/${d}
	done

	echo "#!bin/sh" >>/root/grub-inst.sh
	if grep -qs "/boot" /root/etc/fstab; then
		echo "mount /boot" >>/root/grub-inst.sh
	fi
	echo "update-grub >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	echo "grub-install $device >>/var/log/ucc-installation.log 2>&1" >>/root/grub-inst.sh
	if grep -qs "/boot" /root/etc/fstab; then
		echo "umount /boot" >>/root/grub-inst.sh
	fi

	chmod +x /root/grub-inst.sh
	chroot root ./grub-inst.sh
	rm /root/grub-inst.sh

	for d in dev sys proc; do
		mount -o move /root/${d} /${d}
	done
		
}

## Ask if the partiton should be done and start the post installation
## configuration
ucc_installation()
{
	local partition_device

	# clear

	test -e /scripts/ucc-config/partition_info && . /scripts/ucc-config/partition_info

	partition_device="$(_search_device ${device})"
	if [ $? != 0 ]; then
		echo "ERROR: Failed to search device."
		panic "Dropping to a shell!"
	fi

	# Load keyboard drivers
	modprobe i8042
	modprobe atkbd

	# Ensure the console is prepared for the user interaction
	run_scripts /scripts/panic

	if [ "$continuation_prompt" = "false" ] || [ "$FORCE_PARTITION" = "yes" ]; then
		if [ -z "$FORCE_PARTITION_TIMEOUT" ]; then
			FORCE_PARTITION_TIMEOUT=60
		fi
		echo "Starting partitioning in $FORCE_PARTITION_TIMEOUT seconds. Press CTRL-C to abort."
		sleep $FORCE_PARTITION_TIMEOUT
		partition "$partition_device"
	else
		echo -e "$continuation_message" | sed -e "s|@PARTITION_DEVICE@|$partition_device|g"

		if [ -z "$continuation_dialog" -o -z "$continuation_dialog_no" -o -z "$continuation_dialog_yes" -o -z "$continuation_dialog_error" ]; then
			echo "ERROR: continuation_dialog variables are not set."
			panic "Dropping to a shell!"
		fi

		while true; do
			echo -ne "$continuation_dialog"
			read answer
			
			if [ "$answer" = "$continuation_dialog_no" ]; then
				panic
				break
			elif [ "$answer" = "$continuation_dialog_yes" ]; then
				partition "$partition_device"
				break
			else
				echo -e "$continuation_dialog_error"
			fi
		done

	fi

	# Search image
	_update_local_image
	
	# Write fstab
	_write_fstab

	# Copy files from image to local partitions
	_copy_files

	# Install grub
	_install_grub "$partition_device"
}

## Start the network
_start_dhcpclient()
{
	local net_dev="$1"

	# Bring up the network if this is not a PXE Boot
	test -n "$ip" && return
	echo "INFO: Starting dhcp client"

	ifconfig "$net_dev" up
	udhcpc -s /etc/udhcpc/default.script -i "$net_dev" -b
}

# start the network depending on the configuration in the image
_start_network()
{
	# Image is mounted as /ucc_tmp/root
	chroot /root /usr/sbin/ucr --shell search interfaces gateway nameserver>/tmp/ucr_interfaces
	cat /tmp/ucr_interfaces | while read line; do
		if [ -n "$(echo $line | grep _type=dhcp)" ]; then
			iface="$(echo $line | sed -e 's|interfaces_\(.*\)_type=.*|\1|')"
			ifconfig "${iface}" up
			udhcpc -s /etc/udhcpc/default.script -i "${iface}" -b
		elif [ -n "$(echo $line | grep _address=)" ]; then
			iface="$(echo $line | sed -e 's|interfaces_\(.*\)_address=.*|\1|')"
			addr=$(cat /tmp/ucr_interfaces | sed -ne "s|interfaces_${iface}_address=||p")
			mask=$(cat /tmp/ucr_interfaces | sed -ne "s|interfaces_${iface}_netmask=||p")
			ifconfig "${iface}" "${addr}" netmask "${mask}" up
		fi
	done
	rm /tmp/ucr_interfaces
}

## Update the local UCC image
ucc_update()
{
	mkdir -p /ucc_tmp/root

	# If the root device was set to search or /dev/nfs and the system
	# should be updated, this system must be installed
	if [ "${ROOT}" = "search" -o "${ROOT}" = "/dev/nfs" ]; then
		if ! _mount_local_root_device; then
			echo "A local root device has not been found. Switch to the installation mode!"
			ucc_installation
			return
		fi

		_update_local_image

	else
		# In this case we boot from local boot menu
		# TODO: 
		# 		mount the local root device
		#		bring up the local network with the configuration from the root device
		#		chroot into the local boot device
		#		search for images updates
		mount ${ROOT} /ucc_tmp/root

		if _mount_image; then
			if [ ! -e /root/var/univention-join/joined ]; then
				# The system is not joined. An image upgrade 
				# is not possible. So dive into the image and boot
				_umount_image
				_final_root_mount
			else
				if _start_network; then
					if chroot /root /usr/share/univention-ucc-initramfs/scripts/generate_upgrade_script >/tmp/upgrade_script; then
						chmod +x /tmp/upgrade_script
						_umount_image
						if /tmp/upgrade_script; then
							_final_root_mount
						fi
					fi
				fi
			fi
		fi
	fi

	return 0
}

_mount_local_root_device()
{
	local device
	echo "INFO: Mount local root device"

	umount /ucc_tmp/root

	cat /proc/partitions | grep -v ^major | awk '{print $1" "$2" "$4}' | while read major minor device; do
		ID_FS_TYPE=""
		mount_option=""

		test -z "$device" && continue

		eval "$(blkid -o udev /dev/$device)"
		if [ -n "$ID_FS_TYPE" ]; then
			mount_option="-t $ID_FS_TYPE"
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		if [ "$minor" = 0 ]; then
			sys_path="/sys/block/${device}"
		else
			# get major device for sys ro path
			major_device="$(awk '{if ($1=='$major' && $2==0) { print $4}}' /proc/partitions)"
			sys_path="/sys/block/${major_device}/${device}"
		fi
		if [ -e "${sys_path}/ro" ]; then
			ro="$(cat ${sys_path}/ro)"
			if [ "$ro" != 0 ]; then
				# Skipping read-only device
				continue
			fi
		fi

		# include/linux/genhd.h: GENHD_FL_CD
		if [ -e "${sys_path}/capability)" ]; then
			cap="$(cat ${sys_path}/capability)"
			cap=$(echo "obase=10;ibase=16;${cap}" | bc)
			if [ "$((cap & 8))" = 8 ]; then
				# Skipping CD device
				continue
			fi
		fi
		if mount $mount_option /dev/$device /ucc_tmp/root; then

			if [ -e "/ucc_tmp/root/ucc_root_device" ]; then
				# This is the root device
				echo "Found a local ucc root device: /dev/$device"
				break
			else
				umount /ucc_tmp/root
			fi

		fi
	done

	test -e "/ucc_tmp/root/ucc_root_device"
	return $?
}

## Boot into the local UCC image
ucc_image_local()
{
	mkdir -p /ucc_tmp/root

	if [ "${ROOT}" = "search" -o "${ROOT}" = "/dev/nfs" ]; then
		if ! _mount_local_root_device; then
			echo "ERROR: local root device was not found. Try kernel commandline argument root=</dev/...>"
			panic "Dropping to a shell!"
		fi
	else
		mount ${ROOT} /ucc_tmp/root
	fi

	if [ -n "${IMAGE}" -a -e "/ucc_tmp/root/${IMAGE}" ]; then
		mount -o loop "/ucc_tmp/root/${IMAGE}" /root/
		mount -o move /ucc_tmp/root /root/ucc_root
	elif [ -e "/ucc_tmp/root/local_image" ]; then
		# Use the local image if no image was given via /proc/cmdline
		local_image="$(cat /ucc_tmp/root/local_image)"
		mount -o loop "/ucc_tmp/root/$local_image" /root/
		mount -o move /ucc_tmp/root /root/ucc_root
	fi

	if ! mount | grep -qs " on /root "; then
		echo "ERROR: An UCC image was not found!"
		panic "Dropping to a shell!"
	fi
}

ucc_image_ro()
{
	local device

	mode="$1" # overlayfs or aufs

	if _mount_local_boot_device; then

		modprobe "$mode"

		mkdir -p /ucc_tmp/root-ro
		mkdir -p /ucc_tmp/root-rw
		
		mount -t tmpfs tmpfs-root /ucc_tmp/root-rw

		if [ -n "${IMAGE}" -a -e "/ucc_tmp/boot_medium/${IMAGE}" ]; then
			mount -o loop,ro,noload /ucc_tmp/boot_medium/${IMAGE} /ucc_tmp/root-ro
			break
		fi

		if ! mount | grep -qs " on /ucc_tmp/root-ro "; then
			echo "ERROR: An UCC image was not found!"
			panic "Dropping to a shell!"
		fi
			
		if [ "$mode" = "aufs" ]; then
			mount -t aufs -o dirs=/ucc_tmp/root-rw:/ucc_tmp/root-ro=ro aufs /root
		else
			mount -t overlayfs -o lowerdir=/ucc_tmp/root-ro,upperdir=/ucc_tmp/root-rw overlayfs-root /root/
		fi

		mkdir -p /root/root-rw /root/root-ro /root/root-boot_medium
		mount -o move /ucc_tmp/root-rw /root/root-rw
		mount -o move /ucc_tmp/root-ro /root/root-ro
		mount -o move /ucc_tmp/boot_medium /root/root-boot_medium
	else
		echo "ERROR: A local boot device was not found."
		panic "Dropping to a shell!"
	fi
	
}

# Rollout
ucc_rollout ()
{
	if [ ! -e /root/var/univention-join/joined ]; then
		chroot /root /usr/sbin/univention-join
	fi
}

mountroot()
{
	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
	run_scripts /scripts/local-top
	[ "$quiet" != "y" ] && log_end_msg

	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
	run_scripts /scripts/local-premount
	[ "$quiet" != "y" ] && log_end_msg

	clear

	udevadm settle # wait for udev

	for x in $(cat /proc/cmdline); do
		case $x in
		ucc=*)
			UCC=${x#ucc=}
			;;
		image=*)
			IMAGE=${x#image=}
			;;
		share=*)
			SHARE=${x#share=}
			;;
		force_partition)
			FORCE_PARTITION=true
			;;
		force_partition_timeout=*)
			FORCE_PARTITION_timeout=${x#force_partition_timeout=}
			;;
		net_dev)
			net_dev={x#net_dev=}
			;;
		esac
	done

	# Set defaults
	test -z "$ROOT" && ROOT="search"
	test -z "$net_dev" && net_dev="eth0"

	export IMAGE SHARE FORCE_PARTITION FORCE_PARTITION_TIMEOUT

	if [ "$UCC" = "installation" ]; then 
		echo "Starting UCC installation mode"
		sleep 1 # Give udevadm one more second
		ucc_installation
	elif [ "$UCC" = "update" ]; then
		echo "Starting UCC update mode"
		_start_dhcpclient "$net_dev"
		ucc_update
	elif [ "$UCC" = "rollout" ]; then
		echo "Starting UCC rollout mode"
		_start_dhcpclient "$net_dev"
		ucc_update
		ucc_rollout
	elif [ "$UCC" = "local" -o "$UCC" = "none" ]; then
		echo "Starting UCC local mode"
		ucc_image_local
	elif [ "$UCC" = "overlayfs" ]; then
		echo "Starting UCC overlayfs mode"
		ucc_image_ro overlayfs
	elif [ "$UCC" = "aufs" ]; then
		echo "Starting UCC aufs mode"
		ucc_image_ro aufs
	elif [ "$UCC" = "shell" -o "$UCC" = "debug" ]; then
		echo "Starting UCC shell"
		panic "Dropping to a shell!"
	else
		echo "Use local as fallback mode"
		ucc_image_local
	fi

}
